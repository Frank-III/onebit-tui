///| Demo with Event Loop and Real Keyboard Input
///| Shows how to create an interactive TUI application with actual input handling

fn main {
  println("=== OneBit-TUI Interactive Event Loop Demo ===")
  println("Controls:")
  println("  1-5: Toggle buttons on/off")
  println("  ←→: Navigate between buttons")
  println("  Space: Toggle current button")
  println("  q/ESC: Quit")
  println("")
  println("Press any key to start...")
  
  // Set terminal to raw mode for input
  if @ffi.set_terminal_raw_mode() != 0 {
    println("Failed to set terminal to raw mode")
    return
  }
  
  // Initialize renderer
  match @ffi.Renderer::new(80, 24) {
    None => {
      let _ = @ffi.restore_terminal_mode()
      println("Failed to initialize renderer")
      return
    }
    Some(renderer) => {
      // Set up renderer
      renderer.set_use_thread(true)
      renderer.set_background_color(0.05, 0.05, 0.15, 1.0)
      
      // Initialize state
      let mut selected_button = 0
      let button_states = FixedArray::make(5, false)
      let mut running = true
      let mut message = "Use arrow keys to navigate, Space to toggle, 1-5 for direct toggle"
      let mut frame_count = 0
      let mut last_key = "None"
      
      // Main event loop with real input
      while running {
        // Get buffer and clear
        let buffer = renderer.get_next_buffer()
        buffer.clear(0.05, 0.05, 0.15, 1.0)
        
        // Draw UI
        draw_ui_with_status(buffer, selected_button, button_states, message, frame_count, last_key)
        
        // Render
        renderer.render(force=false)
        
        // Read input events (keyboard, mouse, resize)
        let input_event = @ffi.read_input_event()
        match input_event {
          @ffi.InputEvent::Key(key) => {
            match key {
              @ffi.KeyEvent::Char(c) => {
                last_key = "Char: " + c.to_string()
                // Handle character keys
                if c == 113 || c == 81 {  // 'q' or 'Q'
                  running = false
                  message = "Quitting..."
                } else if c >= 49 && c <= 53 {  // '1' to '5'
                  let button_idx = c - 49
                  button_states[button_idx] = not(button_states[button_idx])
                  message = "Toggled button " + (button_idx + 1).to_string()
                } else if c == 32 {  // Space
                  button_states[selected_button] = not(button_states[selected_button])
                  message = "Toggled button " + (selected_button + 1).to_string()
                }
              }
              @ffi.KeyEvent::Escape => {
                last_key = "ESC"
                running = false
                message = "ESC pressed - exiting..."
              }
              @ffi.KeyEvent::ArrowLeft => {
                last_key = "Arrow Left"
                if selected_button > 0 {
                  selected_button = selected_button - 1
                  message = "Selected button " + (selected_button + 1).to_string()
                }
              }
              @ffi.KeyEvent::ArrowRight => {
                last_key = "Arrow Right"
                if selected_button < 4 {
                  selected_button = selected_button + 1
                  message = "Selected button " + (selected_button + 1).to_string()
                }
              }
              @ffi.KeyEvent::Enter => {
                last_key = "Enter"
                button_states[selected_button] = not(button_states[selected_button])
                message = "Activated button " + (selected_button + 1).to_string()
              }
              _ => {
                last_key = "Unknown key"
              }
            }
          }
          @ffi.InputEvent::None => {
            // No input available, continue
            ()
          }
          _ => {
            // Other input types (mouse, resize) - ignore for this demo
            ()
          }
        }
        
        frame_count = frame_count + 1
        
        // Small delay to prevent high CPU usage
        // In a real app, you might use a proper frame timing mechanism
      }
      
      // Clean up
      renderer.destroy()
      let _ = @ffi.restore_terminal_mode()
      println("\nInteractive demo completed!")
      println("Total frames rendered: " + frame_count.to_string())
    }
  }
}

fn draw_ui_with_status(
  buffer : @ffi.Buffer,
  selected : Int,
  states : FixedArray[Bool],
  message : String,
  frame : Int,
  last_key : String
) -> Unit {
  // Draw title
  buffer.draw_text(
    "Interactive Event Loop Demo",
    25_U, 2_U,
    fg_r=1.0, fg_g=0.8, fg_b=0.3,
    bold=true
  )
  
  // Draw frame counter
  let frame_text = "Frame: " + frame.to_string()
  buffer.draw_text(
    frame_text,
    60_U, 2_U,
    fg_r=0.5, fg_g=0.5, fg_b=0.5
  )
  
  // Draw last key pressed
  let key_text = "Last Key: " + last_key
  buffer.draw_text(
    key_text,
    5_U, 4_U,
    fg_r=0.6, fg_g=0.8, fg_b=0.6
  )
  
  // Draw buttons
  for i = 0; i < 5; i = i + 1 {
    let x = (10 + i * 14).reinterpret_as_uint()
    let y = 8_U
    let width = 12_U
    let height = 4_U
    
    // Determine colors based on state
    let is_selected = i == selected
    let is_active = states[i]
    
    let bg_r = if is_active { 0.2 } else { 0.1 }
    let bg_g = if is_active { 0.4 } else { 0.1 }
    let bg_b = if is_selected { 0.5 } else { 0.2 }
    
    // Draw button background
    buffer.fill_rect(x, y, width, height, bg_r, bg_g, bg_b, 1.0)
    
    // Draw selection border if selected
    if is_selected {
      // Draw border around selected button
      buffer.fill_rect(x - 1_U, y - 1_U, width + 2_U, 1_U, 0.8, 0.8, 0.2, 1.0)  // Top
      buffer.fill_rect(x - 1_U, y + height, width + 2_U, 1_U, 0.8, 0.8, 0.2, 1.0)  // Bottom
      buffer.fill_rect(x - 1_U, y, 1_U, height, 0.8, 0.8, 0.2, 1.0)  // Left
      buffer.fill_rect(x + width, y, 1_U, height, 0.8, 0.8, 0.2, 1.0)  // Right
    }
    
    // Draw button label
    let label = "BTN " + (i + 1).to_string()
    let label_x = x + 3_U
    let label_y = y + 1_U
    
    let text_r = if is_active { 1.0 } else { 0.7 }
    let text_g = if is_active { 1.0 } else { 0.7 }
    let text_b = if is_selected { 1.0 } else { 0.7 }
    
    buffer.draw_text(
      label,
      label_x, label_y,
      fg_r=text_r, fg_g=text_g, fg_b=text_b,
      bold=is_selected
    )
    
    // Draw state indicator
    let state_text = if is_active { "[ON]" } else { "[OFF]" }
    buffer.draw_text(
      state_text,
      label_x, label_y + 1_U,
      fg_r=0.5, fg_g=if is_active { 1.0 } else { 0.5 }, fg_b=0.5
    )
  }
  
  // Draw message
  buffer.draw_text(
    message,
    5_U, 16_U,
    fg_r=0.8, fg_g=0.8, fg_b=1.0
  )
  
  // Draw instructions
  buffer.draw_text(
    "←→: Navigate | Space/Enter: Toggle | 1-5: Direct | q/ESC: Quit",
    8_U, 20_U,
    fg_r=0.5, fg_g=0.5, fg_b=0.5
  )
}

