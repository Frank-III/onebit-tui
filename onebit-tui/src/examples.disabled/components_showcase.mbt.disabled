///|
/// Components Showcase
/// Demonstrates all OneBit TUI components

fn main {
  println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
  println("â•‘           ğŸŒ™ OneBit TUI Components Showcase               â•‘")
  println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
  println("")
  
  demo_text_input()
  demo_list()
  demo_table()
  demo_modal()
  demo_box()
  demo_reactive()
  
  println("\nâœ¨ All components are working! Use them to build amazing TUIs.")
}

fn demo_text_input() {
  println("\nğŸ“ TextInput Component:")
  println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  
  let mut input = @components.TextInput::new(
    value="Hello, OneBit!",
    width=30,
    placeholder="Type something..."
  )
  
  // Render to buffer
  let buf = @core.Buffer::new(35, 3)
  input.render(buf, 0, 0)
  
  // Show buffer content
  print_buffer(buf, 3)
  
  // Demonstrate editing
  input.handle_char('ğŸŒ™', 14)
  println("After adding moon emoji: " + input.value)
}

fn demo_list() {
  println("\nğŸ“‹ List Component:")
  println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  
  let items = [
    @components.ListItem::Text("âœ… Core components working"),
    @components.ListItem::Text("âœ… Reactive state system"),
    @components.ListItem::Text("âœ… Buffer rendering"),
    @components.ListItem::Separator,
    @components.ListItem::Text("ğŸš§ Event loop (in progress)"),
    @components.ListItem::Text("ğŸš§ Terminal FFI (in progress)")
  ]
  
  let mut list = @components.List::new(
    items=items,
    selected=1,
    style=@components.ListStyle::new(
      highlight_color=@core.Color::Yellow,
      selected_prefix="â–¶ ",
      unselected_prefix="  "
    )
  )
  
  let buf = @core.Buffer::new(40, 8)
  list.render(buf, 0, 0)
  print_buffer(buf, 6)
}

fn demo_table() {
  println("\nğŸ“Š Table Component:")
  println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  
  let mut table = @components.Table::new(
    headers=["Component", "Status", "Progress"],
    widths=[15, 10, 12]
  )
  
  table.add_row(["TextInput", "Complete", "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%"])
  table.add_row(["List", "Complete", "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%"])
  table.add_row(["Table", "Complete", "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%"])
  table.add_row(["Modal", "Complete", "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%"])
  table.add_row(["Box", "Complete", "â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%"])
  
  let buf = @core.Buffer::new(45, 10)
  table.render(buf, 0, 0)
  print_buffer(buf, 7)
}

fn demo_modal() {
  println("\nğŸ’¬ Modal Component:")
  println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  
  let modal = @components.Modal::new(
    title="ğŸ‰ Success!",
    content="OneBit TUI is ready!\n\nBuild amazing terminal UIs\nwith type safety and reactive state.",
    width=40,
    height=8,
    style=@components.ModalStyle::new(
      border_color=@core.Color::Green,
      title_color=@core.Color::Yellow,
      content_color=@core.Color::White
    )
  )
  
  let buf = @core.Buffer::new(42, 10)
  modal.render(buf, 0, 0)
  print_buffer(buf, 8)
}

fn demo_box() {
  println("\nğŸ“¦ Box Component:")
  println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  
  let box = @components.Box::new(
    x=0, y=0,
    width=30, height=6,
    border=@components.Border::new(
      style=@components.BorderStyle::Rounded,
      color=@core.Color::Cyan
    ),
    title="OneBit Box"
  )
  
  let buf = @core.Buffer::new(32, 8)
  box.render(buf, 0, 0)
  
  // Add content inside the box
  buf.write_string(2, 2, "â€¢ Flexible layouts")
  buf.write_string(2, 3, "â€¢ Custom borders")
  buf.write_string(2, 4, "â€¢ Title support")
  
  print_buffer(buf, 6)
}

fn demo_reactive() {
  println("\nâš¡ Reactive System:")
  println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
  
  // Create reactive values
  let count = @reactive.signal(0)
  let doubled = @reactive.computed(fn() { count.get() * 2 })
  let message = @reactive.computed(fn() {
    "Count: " + count.get().to_string() + ", Doubled: " + doubled.get().to_string()
  })
  
  println("Initial: " + message.get())
  
  count.set(5)
  println("After setting to 5: " + message.get())
  
  count.set(10)
  println("After setting to 10: " + message.get())
  
  // Demonstrate effects
  let effect_called = @reactive.signal(0)
  @reactive.effect(fn() {
    let _ = count.get() // Track dependency
    effect_called.set(effect_called.get() + 1)
  })
  
  count.set(15)
  println("Effect was called " + effect_called.get().to_string() + " times")
}

fn print_buffer(buf : @core.Buffer, height : Int) {
  for y = 0; y < height; y = y + 1 {
    let mut line = ""
    for x = 0; x < buf.width; x = x + 1 {
      match buf.get(x, y) {
        Some(cell) => line = line + cell.char
        None => line = line + " "
      }
    }
    // Only print non-empty lines
    let trimmed = trim_end(line)
    if trimmed.length() > 0 {
      println(trimmed)
    }
  }
}

fn trim_end(s : String) -> String {
  let mut end = s.length()
  while end > 0 && @core.string_substring(s, end - 1, 1) == " " {
    end = end - 1
  }
  @core.string_substring(s, 0, end)
}