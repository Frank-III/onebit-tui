///| Core Element trait - base for all UI components
///| This defines the interface that all UI elements must implement

// Basic geometric types
pub struct Rect {
  x : Int
  y : Int
  width : Int
  height : Int
}

pub fn Rect::new(x : Int, y : Int, width : Int, height : Int) -> Rect {
  { x, y, width, height }
}

// Layout constraints passed down from parent
pub struct Constraints {
  min_width : Int?
  max_width : Int?
  min_height : Int?
  max_height : Int?
}

pub fn Constraints::default() -> Constraints {
  {
    min_width: None,
    max_width: None,
    min_height: None,
    max_height: None
  }
}

pub fn Constraints::exact(width : Int, height : Int) -> Constraints {
  {
    min_width: Some(width),
    max_width: Some(width),
    min_height: Some(height),
    max_height: Some(height)
  }
}

pub fn Constraints::max(width : Int, height : Int) -> Constraints {
  {
    min_width: Some(0),
    max_width: Some(width),
    min_height: Some(0),
    max_height: Some(height)
  }
}

// Size after layout
pub struct Size {
  width : Int
  height : Int
}

pub fn Size::new(width : Int, height : Int) -> Size {
  { width, height }
}

// Event handling result
pub enum EventResult {
  Consumed   // Event was handled, stop propagation
  Ignored    // Event not handled, continue propagation
}

// Base trait for all UI components (renamed to avoid conflict with tui.mbt's Element)
pub trait Component {
  // Calculate size based on constraints
  measure(Self, Constraints) -> Size
  
  // Perform layout (position children)
  layout(Self, Rect) -> Unit
  
  // Render to buffer
  render(Self, @ffi.Buffer, Rect) -> Unit
  
  // Handle input events
  handle_event(Self, @ffi.InputEvent) -> EventResult
  
  // Get/set focus state
  is_focused(Self) -> Bool
  set_focused(Self, Bool) -> Unit
}

// Helper functions for common operations
pub fn constrain_size(size : Size, constraints : Constraints) -> Size {
  let mut width = size.width
  let mut height = size.height
  
  // Apply min constraints
  match constraints.min_width {
    Some(min) => if width < min { width = min }
    None => ()
  }
  
  match constraints.min_height {
    Some(min) => if height < min { height = min }
    None => ()
  }
  
  // Apply max constraints
  match constraints.max_width {
    Some(max) => if width > max { width = max }
    None => ()
  }
  
  match constraints.max_height {
    Some(max) => if height > max { height = max }
    None => ()
  }
  
  { width, height }
}

// Check if a point is within a rectangle
pub fn Rect::contains(self : Rect, x : Int, y : Int) -> Bool {
  x >= self.x && 
  x < self.x + self.width && 
  y >= self.y && 
  y < self.y + self.height
}

// Get the inner rect after applying padding
pub fn Rect::inset(self : Rect, top : Int, right : Int, bottom : Int, left : Int) -> Rect {
  {
    x: self.x + left,
    y: self.y + top,
    width: self.width - left - right,
    height: self.height - top - bottom
  }
}

// Import color from tui module
// For now, let's define Color here to avoid circular dependencies
pub enum Color {
  Black
  Red
  Green
  Yellow
  Blue
  Magenta
  Cyan
  White
  Gray
  BrightRed
  BrightGreen
  BrightYellow
  BrightBlue
  BrightMagenta
  BrightCyan
  BrightWhite
}

// Helper to convert color to RGB values
pub fn color_to_rgb(color : Color) -> (Double, Double, Double) {
  match color {
    Color::Black => (0.0, 0.0, 0.0)
    Color::Red => (0.8, 0.0, 0.0)
    Color::Green => (0.0, 0.8, 0.0)
    Color::Yellow => (0.8, 0.8, 0.0)
    Color::Blue => (0.0, 0.0, 0.8)
    Color::Magenta => (0.8, 0.0, 0.8)
    Color::Cyan => (0.0, 0.8, 0.8)
    Color::White => (0.9, 0.9, 0.9)
    Color::Gray => (0.5, 0.5, 0.5)
    Color::BrightRed => (1.0, 0.0, 0.0)
    Color::BrightGreen => (0.0, 1.0, 0.0)
    Color::BrightYellow => (1.0, 1.0, 0.0)
    Color::BrightBlue => (0.0, 0.0, 1.0)
    Color::BrightMagenta => (1.0, 0.0, 1.0)
    Color::BrightCyan => (0.0, 1.0, 1.0)
    Color::BrightWhite => (1.0, 1.0, 1.0)
  }
}

// Common style properties
pub struct TextStyle {
  foreground : Color?
  background : Color?
  bold : Bool
  italic : Bool
  underline : Bool
}

pub fn TextStyle::default() -> TextStyle {
  TextStyle::{
    foreground: None,
    background: None,
    bold: false,
    italic: false,
    underline: false
  }
}

// Border styles
pub enum BorderStyle {
  None
  Single
  Double
  Rounded
  Thick
}

pub struct Borders {
  style : BorderStyle
  color : Color?
  // Which sides to draw
  top : Bool
  right : Bool
  bottom : Bool
  left : Bool
}

pub fn Borders::all(style : BorderStyle) -> Borders {
  Borders::{
    style,
    color: None,
    top: true,
    right: true,
    bottom: true,
    left: true
  }
}

pub fn Borders::none() -> Borders {
  Borders::{
    style: BorderStyle::None,
    color: None,
    top: false,
    right: false,
    bottom: false,
    left: false
  }
}

// Padding/Margin
pub struct Spacing {
  top : Int
  right : Int
  bottom : Int
  left : Int
}

pub fn Spacing::all(value : Int) -> Spacing {
  Spacing::{
    top: value,
    right: value,
    bottom: value,
    left: value
  }
}

pub fn Spacing::zero() -> Spacing {
  Spacing::{ top: 0, right: 0, bottom: 0, left: 0 }
}

pub fn Spacing::vertical(value : Int) -> Spacing {
  Spacing::{
    top: value,
    right: 0,
    bottom: value,
    left: 0
  }
}

pub fn Spacing::horizontal(value : Int) -> Spacing {
  Spacing::{
    top: 0,
    right: value,
    bottom: 0,
    left: value
  }
}