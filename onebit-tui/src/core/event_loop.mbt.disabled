///| Event Loop for handling terminal input and rendering
///| This is the main runtime for interactive TUI applications

import moonbitlang/core/ref
import moonbitlang/core/hashmap

pub struct EventLoop {
  mut running : Ref[Bool]
  mut renderer : @ffi.Renderer?
  mut root_component : BaseRenderable?
  mut event_handlers : @hashmap.HashMap[String, Array[(Event) -> Bool]]
  mut frame_rate : Int  // Target FPS
  mut last_render_time : Int64
}

pub enum Event {
  KeyPress(key : String, modifiers : KeyModifiers)
  MouseClick(x : Int, y : Int, button : Int)
  MouseMove(x : Int, y : Int)
  MouseScroll(x : Int, y : Int, delta : Int)
  Resize(width : Int, height : Int)
  Timer(id : String)
  Custom(data : @json.Json)
} derive(Show)

pub struct KeyModifiers {
  ctrl : Bool
  alt : Bool
  shift : Bool
  meta : Bool
} derive(Show, Eq)

pub fn EventLoop::new(frame_rate : Int) -> EventLoop {
  {
    running: @ref.Ref::new(false),
    renderer: None,
    root_component: None,
    event_handlers: @hashmap.new(),
    frame_rate,
    last_render_time: 0L,
  }
}

pub fn EventLoop::set_renderer(self : EventLoop, renderer : @ffi.Renderer) -> Unit {
  self.renderer = Some(renderer)
  // Enable mouse and keyboard input
  renderer.enable_mouse(true)
}

pub fn EventLoop::set_root(self : EventLoop, component : @renderable.BaseRenderable) -> Unit {
  self.root_component = Some(component)
}

pub fn EventLoop::on(self : EventLoop, event_type : String, handler : (Event) -> Bool) -> Unit {
  match self.event_handlers.get(event_type) {
    Some(handlers) => handlers.push(handler)
    None => {
      let handlers = [handler]
      self.event_handlers.set(event_type, handlers)
    }
  }
}

pub fn EventLoop::emit(self : EventLoop, event : Event) -> Bool {
  let event_type = match event {
    KeyPress(_, _) => "keypress"
    MouseClick(_, _, _) => "click"
    MouseMove(_, _) => "mousemove"
    MouseScroll(_, _, _) => "scroll"
    Resize(_, _) => "resize"
    Timer(id) => "timer:" + id
    Custom(_) => "custom"
  }
  
  match self.event_handlers.get(event_type) {
    Some(handlers) => {
      for handler in handlers {
        if handler(event) {
          return true  // Event was handled
        }
      }
      false
    }
    None => false
  }
}

pub fn EventLoop::run(self : EventLoop) -> Unit {
  self.running.val = true
  
  // Main event loop
  while self.running.val {
    // Process input events (this would need actual terminal input reading)
    self.process_input()
    
    // Update components that need animation
    self.update_animations()
    
    // Render if needed
    self.render_if_needed()
    
    // Sleep to maintain frame rate
    self.sleep_for_frame_rate()
  }
}

pub fn EventLoop::stop(self : EventLoop) -> Unit {
  self.running.val = false
}

fn EventLoop::process_input(self : EventLoop) -> Unit {
  // TODO: Read from stdin and parse input events
  // This would need FFI bindings to read terminal input
}

fn EventLoop::update_animations(self : EventLoop) -> Unit {
  // TODO: Update any animated components
  match self.root_component {
    Some(root) => {
      // Walk the component tree and update animations
    }
    None => ()
  }
}

fn EventLoop::render_if_needed(self : EventLoop) -> Unit {
  match (self.renderer, self.root_component) {
    (Some(renderer), Some(root)) => {
      let buffer = renderer.get_next_buffer()
      
      // Clear buffer
      buffer.clear()
      
      // Render component tree
      self.render_component(root, buffer)
      
      // Swap buffers and render
      renderer.render(false)
    }
    _ => ()
  }
}

fn EventLoop::render_component(
  self : EventLoop,
  component : @renderable.BaseRenderable,
  buffer : @ffi.Buffer
) -> Unit {
  // Render this component
  match component.render_fn {
    Some(render) => render(component, buffer.to_terminal_buffer())
    None => ()
  }
  
  // Render children
  for child in component.children {
    self.render_component(child, buffer)
  }
}

fn EventLoop::sleep_for_frame_rate(self : EventLoop) -> Unit {
  // TODO: Implement actual sleep based on frame rate
  // This would need FFI bindings for timing
}