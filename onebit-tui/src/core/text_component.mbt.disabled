///| Text Component - Renders text with optional styling

pub struct Text {
  content : String
  style : TextStyle
  mut focused : Bool
  mut bounds : Rect?
}

pub fn Text::new(content : String) -> Text {
  {
    content,
    style: TextStyle::default(),
    focused: false,
    bounds: None
  }
}

// Builder methods
pub fn Text::color(self : Text, color : Color) -> Text {
  self.style.foreground = Some(color)
  self
}

pub fn Text::background(self : Text, color : Color) -> Text {
  self.style.background = Some(color)
  self
}

pub fn Text::bold(self : Text) -> Text {
  self.style.bold = true
  self
}

pub fn Text::italic(self : Text) -> Text {
  self.style.italic = true
  self
}

pub fn Text::underline(self : Text) -> Text {
  self.style.underline = true
  self
}

pub fn Text::style(self : Text, style : TextStyle) -> Text {
  self.style = style
  self
}

// Helper to calculate text dimensions
fn measure_text(content : String) -> (Int, Int) {
  // Split and collect into array
  let mut lines : Array[String] = []
  let iter = content.split("\n")  // Use string not char
  iter.each(fn(line) { lines.push(line.to_string()) })
  
  let height = lines.length()
  let mut width = 0
  
  for i = 0; i < lines.length(); i = i + 1 {
    let line = lines[i]
    let line_width = line.length()
    if line_width > width {
      width = line_width
    }
  }
  
  (width, height)
}

// Helper to apply text attributes
fn get_attributes(style : TextStyle) -> Byte {
  let mut attrs : Byte = 0
  if style.bold { attrs = attrs | 1 }
  if style.italic { attrs = attrs | 2 }
  if style.underline { attrs = attrs | 4 }
  attrs
}

impl Component for Text with
  measure(self : Text, constraints : Constraints) -> Size {
    let (width, height) = measure_text(self.content)
    constrain_size({ width, height }, constraints)
  }
  
  layout(self : Text, bounds : Rect) -> Unit {
    self.bounds = Some(bounds)
  }
  
  render(self : Text, buffer : @ffi.Buffer, bounds : Rect) -> Unit {
    // Get colors
    let fg_color = match self.style.foreground {
      Some(c) => c
      None => Color::White
    }
    let (fg_r, fg_g, fg_b) = color_to_rgb(fg_color)
    
    // Draw background if specified
    match self.style.background {
      Some(bg_color) => {
        let (bg_r, bg_g, bg_b) = color_to_rgb(bg_color)
        
        // Fill background for the text area
        let (text_width, text_height) = measure_text(self.content)
        buffer.fill_rect(
          bounds.x.reinterpret_as_uint(),
          bounds.y.reinterpret_as_uint(),
          text_width.reinterpret_as_uint(),
          text_height.reinterpret_as_uint(),
          bg_r, bg_g, bg_b, 1.0
        )
      }
      None => ()
    }
    
    // Draw text line by line - collect lines into array first
    let mut lines : Array[String] = []
    let iter = self.content.split("\n")  // Use string not char
    iter.each(fn(line) { lines.push(line.to_string()) })
    
    let attrs = get_attributes(self.style)
    
    for i = 0; i < lines.length(); i = i + 1 {
      if i >= bounds.height {
        break  // Don't draw outside bounds
      }
      
      let line = lines[i]
      // Truncate line if too long - manual substring
      let display_line = if line.length() > bounds.width {
        let mut result = ""
        for j = 0; j < bounds.width && j < line.length(); j = j + 1 {
          result = result + line[j].to_string()
        }
        result
      } else {
        line
      }
      
      // Draw the line
      if display_line.length() > 0 {
        buffer.draw_text(
          display_line,
          bounds.x.reinterpret_as_uint(),
          (bounds.y + i).reinterpret_as_uint(),
          fg_r=fg_r, fg_g=fg_g, fg_b=fg_b,
          attributes=attrs
        )
      }
    }
  }
  
  handle_event(self : Text, _event : @ffi.InputEvent) -> EventResult {
    // Text doesn't handle events by default
    EventResult::Ignored
  }
  
  is_focused(self : Text) -> Bool {
    self.focused
  }
  
  set_focused(self : Text, focused : Bool) -> Unit {
    self.focused = focused
  }