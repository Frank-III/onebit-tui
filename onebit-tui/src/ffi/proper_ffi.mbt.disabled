///| Proper FFI bindings for OpenTUI
///| Based on the official C API header

// Opaque types for C pointers (prefix with Proper to avoid conflicts)
type ProperCliRenderer
type ProperOptimizedBuffer

// Test if library is loaded
extern "C" fn mb_test_library() -> Int = "mb_test_library"

// Renderer management functions
extern "C" fn mb_createRenderer(width : UInt, height : UInt) -> ProperCliRenderer? = "mb_createRenderer"
extern "C" fn mb_destroyRenderer(renderer : ProperCliRenderer, use_alternate_screen : Bool, split_height : UInt) -> Unit = "mb_destroyRenderer"
extern "C" fn mb_setBackgroundColor(renderer : ProperCliRenderer, color : FixedArray[Double]) -> Unit = "mb_setBackgroundColor"
extern "C" fn mb_clearTerminal(renderer : ProperCliRenderer) -> Unit = "mb_clearTerminal"
extern "C" fn mb_render(renderer : ProperCliRenderer, force : Bool) -> Unit = "mb_render"
extern "C" fn mb_getNextBuffer(renderer : ProperCliRenderer) -> ProperOptimizedBuffer? = "mb_getNextBuffer"

// Buffer functions
extern "C" fn mb_getBufferWidth(buffer : ProperOptimizedBuffer) -> UInt = "mb_getBufferWidth"
extern "C" fn mb_getBufferHeight(buffer : ProperOptimizedBuffer) -> UInt = "mb_getBufferHeight"
extern "C" fn mb_bufferClear(buffer : ProperOptimizedBuffer, bg : FixedArray[Double]) -> Unit = "mb_bufferClear"
extern "C" fn mb_bufferDrawText(
  buffer : ProperOptimizedBuffer,
  text : Bytes,
  text_len : UInt,
  x : UInt,
  y : UInt,
  fg : FixedArray[Double],
  bg : FixedArray[Double]?,
  attributes : Byte
) -> Unit = "mb_bufferDrawText"
extern "C" fn mb_bufferFillRect(
  buffer : ProperOptimizedBuffer,
  x : UInt,
  y : UInt,
  width : UInt,
  height : UInt,
  bg : FixedArray[Double]
) -> Unit = "mb_bufferFillRect"

// Cursor functions
extern "C" fn mb_setCursorPosition(renderer : ProperCliRenderer, x : Int, y : Int, visible : Bool) -> Unit = "mb_setCursorPosition"

// Mouse functions
extern "C" fn mb_enableMouse(renderer : ProperCliRenderer, enable_movement : Bool) -> Unit = "mb_enableMouse"

/// High-level Renderer wrapper
pub struct ProperRenderer {
  handle : ProperCliRenderer
}

/// High-level Buffer wrapper
pub struct ProperBuffer {
  handle : ProperOptimizedBuffer
  width : UInt
  height : UInt
}

/// Test if the OpenTUI library is available
pub fn test_library() -> Bool {
  mb_test_library() == 1
}

/// Create a new renderer
pub fn ProperRenderer::new(width : UInt, height : UInt) -> ProperRenderer? {
  match mb_createRenderer(width, height) {
    Some(handle) => Some(ProperRenderer { handle })
    None => None
  }
}

/// Destroy the renderer
pub fn ProperRenderer::destroy(self : ProperRenderer) -> Unit {
  mb_destroyRenderer(self.handle, true, 0)
}

/// Set background color
pub fn ProperRenderer::set_background_color(self : ProperRenderer, r : Double, g : Double, b : Double, a : Double) -> Unit {
  let color = FixedArray::make(4, 0.0)
  color[0] = r
  color[1] = g
  color[2] = b
  color[3] = a
  mb_setBackgroundColor(self.handle, color)
}

/// Clear the terminal
pub fn ProperRenderer::clear_terminal(self : ProperRenderer) -> Unit {
  mb_clearTerminal(self.handle)
}

/// Render the current frame
pub fn ProperRenderer::render(self : ProperRenderer, force : Bool) -> Unit {
  mb_render(self.handle, force)
}

/// Get the next buffer for rendering
pub fn ProperRenderer::get_next_buffer(self : ProperRenderer) -> ProperBuffer? {
  match mb_getNextBuffer(self.handle) {
    None => None
    Some(handle) => {
      let width = mb_getBufferWidth(handle)
      let height = mb_getBufferHeight(handle)
      Some(ProperBuffer { handle, width, height })
    }
  }
}

/// Set cursor position
pub fn ProperRenderer::set_cursor(self : ProperRenderer, x : Int, y : Int, visible : Bool) -> Unit {
  mb_setCursorPosition(self.handle, x, y, visible)
}

/// Enable mouse support
pub fn ProperRenderer::enable_mouse(self : ProperRenderer, enable_movement : Bool) -> Unit {
  mb_enableMouse(self.handle, enable_movement)
}

/// Clear the buffer with a background color
pub fn ProperBuffer::clear(self : ProperBuffer, r : Double, g : Double, b : Double, a : Double) -> Unit {
  let bg = FixedArray::make(4, 0.0)
  bg[0] = r
  bg[1] = g
  bg[2] = b
  bg[3] = a
  mb_bufferClear(self.handle, bg)
}

/// Draw text to the buffer
pub fn ProperBuffer::draw_text(
  self : ProperBuffer,
  text : String,
  x : UInt,
  y : UInt,
  fg_r : Double,
  fg_g : Double,
  fg_b : Double,
  fg_a : Double,
  bg_r~ : Double? = None,
  bg_g~ : Double? = None,
  bg_b~ : Double? = None,
  bg_a~ : Double? = None,
  bold~ : Bool = false,
  underline~ : Bool = false
) -> Unit {
  let text_bytes = text.to_bytes()
  let text_len = text_bytes.length().reinterpret_as_uint()
  
  let fg = FixedArray::make(4, 0.0)
  fg[0] = fg_r
  fg[1] = fg_g
  fg[2] = fg_b
  fg[3] = fg_a
  
  let mut attributes : Byte = 0b0
  if bold { attributes = attributes.lor(0b1) }
  if underline { attributes = attributes.lor(0b1000) }
  
  // Handle optional background
  match (bg_r, bg_g, bg_b, bg_a) {
    (Some(r), Some(g), Some(b), Some(a)) => {
      let bg_color = FixedArray::make(4, 0.0)
      bg_color[0] = r
      bg_color[1] = g
      bg_color[2] = b
      bg_color[3] = a
      mb_bufferDrawText(self.handle, text_bytes, text_len, x, y, fg, Some(bg_color), attributes)
    }
    _ => {
      mb_bufferDrawText(self.handle, text_bytes, text_len, x, y, fg, None, attributes)
    }
  }
}

/// Fill a rectangle with a color
pub fn ProperBuffer::fill_rect(
  self : ProperBuffer,
  x : UInt,
  y : UInt,
  width : UInt,
  height : UInt,
  r : Double,
  g : Double,
  b : Double,
  a : Double
) -> Unit {
  let bg = FixedArray::make(4, 0.0)
  bg[0] = r
  bg[1] = g
  bg[2] = b
  bg[3] = a
  mb_bufferFillRect(self.handle, x, y, width, height, bg)
}