///|
/// Core renderable component system for onebit-tui
pub type RGBA {
  r: Double
  g: Double
  b: Double
  a: Double
}

pub type TerminalBuffer {
  width: Int
  height: Int
  cells: Array[Char]
  fg_colors: Array[RGBA]
  bg_colors: Array[RGBA]
  styles: Array[TextStyle]
}

pub type TextStyle {
  None
  Bold
  Dim
  Italic
  Underline
  Blink
  Reverse
  Hidden
  Strikethrough
}

impl TerminalBuffer {
  pub fn new(width: Int, height: Int) -> TerminalBuffer {
    TerminalBuffer {
      width,
      height,
      cells: Array::make(width * height, ' '),
      fg_colors: Array::make(width * height, RGBA { r: 1.0, g: 1.0, b: 1.0, a: 1.0 }),
      bg_colors: Array::make(width * height, RGBA { r: 0.0, g: 0.0, b: 0.0, a: 1.0 }),
      styles: Array::make(width * height, TextStyle::None),
    }
  }

  pub fn set_cell(self: TerminalBuffer, x: Int, y: Int, char: Char, fg: RGBA, bg: RGBA, style: TextStyle) -> Unit {
    if x >= 0 && x < self.width && y >= 0 && y < self.height {
      let index = y * self.width + x
      self.cells[index] = char
      self.fg_colors[index] = fg
      self.bg_colors[index] = bg
      self.styles[index] = style
    }
  }
}

///|
/// Rectangle structure for positioning and sizing
pub struct Rect {
  x: Int
  y: Int
  width: Int
  height: Int
}

///|
pub fn Rect::new(x: Int, y: Int, width: Int, height: Int) -> Rect {
  { x, y, width, height }
}

///|
pub fn Rect::contains(self: Rect, px: Int, py: Int) -> Bool {
  px >= self.x && px < self.x + self.width && py >= self.y && py < self.y + self.height
}

///|
pub fn Rect::intersects(self: Rect, other: Rect) -> Bool {
  self.x < other.x + other.width &&
  self.x + self.width > other.x &&
  self.y < other.y + other.height &&
  self.y + self.height > other.y
}

///|
/// Layout constraints for components
pub struct LayoutConstraints {
  min_width: Int
  min_height: Int
  max_width: Int
  max_height: Int
  margin: Int
  padding: Int
}

///|
pub fn LayoutConstraints::new() -> LayoutConstraints {
  {
    min_width: 0,
    min_height: 0,
    max_width: 9999,
    max_height: 9999,
    margin: 0,
    padding: 0,
  }
}

///|
pub fn LayoutConstraints::with_min_size(self: LayoutConstraints, width: Int, height: Int) -> LayoutConstraints {
  { ..self, min_width: width, min_height: height }
}

///|
pub fn LayoutConstraints::with_max_size(self: LayoutConstraints, width: Int, height: Int) -> LayoutConstraints {
  { ..self, max_width: width, max_height: height }
}

///|
pub fn LayoutConstraints::with_margin(self: LayoutConstraints, margin: Int) -> LayoutConstraints {
  { ..self, margin }
}

///|
pub fn LayoutConstraints::with_padding(self: LayoutConstraints, padding: Int) -> LayoutConstraints {
  { ..self, padding }
}

///|
/// Component event for handling user interactions
pub struct ComponentEvent {
  event_type: String
  x: Int
  y: Int
  key: Option[String]
}

///|
/// Renderable trait for all UI components
pub trait Renderable {
  id(Self) -> String
  bounds(Self) -> Rect
  set_bounds(Self, Rect) -> Unit
  layout_constraints(Self) -> LayoutConstraints
  set_layout_constraints(Self, LayoutConstraints) -> Unit
  render(Self, TerminalBuffer) -> Unit
  handle_event(Self, ComponentEvent) -> Bool
  is_visible(Self) -> Bool
  set_visible(Self, Bool) -> Unit
  children(Self) -> Array[Self]
  add_child(Self, Self) -> Unit
  remove_child(Self, String) -> Unit
  parent(Self) -> Option[Self]
  set_parent(Self, Option[Self]) -> Unit
  z_index(Self) -> Int
  set_z_index(Self, Int) -> Unit
  background_color(Self) -> RGBA
  set_background_color(Self, RGBA) -> Unit
  foreground_color(Self) -> RGBA
  set_foreground_color(Self, RGBA) -> Unit
  needs_layout(Self) -> Bool
  mark_needs_layout(Self) -> Unit
  needs_render(Self) -> Bool
  mark_needs_render(Self) -> Unit
  destroy(Self) -> Unit
}

///|
/// Base renderable component implementation
pub struct BaseRenderable {
  mut id: String
  mut bounds: Rect
  mut constraints: LayoutConstraints
  mut visible: Bool
  mut children: Array[BaseRenderable]
  mut parent: Option[BaseRenderable]
  mut z_index: Int
  mut bg_color: RGBA
  mut fg_color: RGBA
  mut needs_layout_flag: Bool
  mut needs_render_flag: Bool
}

///|
pub fn BaseRenderable::new(id: String) -> BaseRenderable {
  {
    id,
    bounds: Rect::new(0, 0, 10, 1),
    constraints: LayoutConstraints::new(),
    visible: true,
    children: [],
    parent: None,
    z_index: 0,
    bg_color: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
    fg_color: { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },
    needs_layout_flag: true,
    needs_render_flag: true,
  }
}

///|
pub fn BaseRenderable::with_bounds(self: BaseRenderable, x: Int, y: Int, width: Int, height: Int) -> BaseRenderable {
  { ..self, bounds: Rect::new(x, y, width, height) }
}

///|
pub fn BaseRenderable::with_colors(self: BaseRenderable, fg: RGBA, bg: RGBA) -> BaseRenderable {
  { ..self, fg_color: fg, bg_color: bg }
}

///|
pub fn BaseRenderable::with_z_index(self: BaseRenderable, z: Int) -> BaseRenderable {
  { ..self, z_index: z }
}

///|
pub fn BaseRenderable::calculate_layout(self: BaseRenderable) -> Unit {
  if not(self.needs_layout_flag) {
    return
  }
  
  let content_width = self.bounds.width - self.constraints.padding * 2
  let content_height = self.bounds.height - self.constraints.padding * 2
  
  let mut current_x = self.bounds.x + self.constraints.padding
  let mut current_y = self.bounds.y + self.constraints.padding
  
  for child in self.children {
    if child.is_visible() {
      let child_bounds = Rect::new(current_x, current_y, child.bounds.width, child.bounds.height)
      child.set_bounds(child_bounds)
      child.calculate_layout()
      current_y += child.bounds.height
    }
  }
  
  self.needs_layout_flag = false
}

///|
pub fn BaseRenderable::render_children(self: BaseRenderable, buffer: TerminalBuffer) -> Unit {
  if not(self.is_visible()) {
    return
  }
  
  let sorted_children = self.children.sort_by(fn(a, b) { a.z_index().compare(b.z_index()) })
  
  for child in sorted_children {
    if child.is_visible() {
      child.render(buffer)
    }
  }
}

///|
pub impl Renderable for BaseRenderable {
  fn id(self: BaseRenderable) -> String {
    self.id
  }
  
  fn bounds(self: BaseRenderable) -> Rect {
    self.bounds
  }
  
  fn set_bounds(self: BaseRenderable, bounds: Rect) -> Unit {
    self.bounds = bounds
    self.mark_needs_layout()
  }
  
  fn layout_constraints(self: BaseRenderable) -> LayoutConstraints {
    self.constraints
  }
  
  fn set_layout_constraints(self: BaseRenderable, constraints: LayoutConstraints) -> Unit {
    self.constraints = constraints
    self.mark_needs_layout()
  }
  
  fn render(self: BaseRenderable, buffer: TerminalBuffer) -> Unit {
    if not(self.is_visible()) {
      return
    }
    
    if self.needs_layout() {
      self.calculate_layout()
    }
    
    // Fill background
    for y in self.bounds.y..(self.bounds.y + self.bounds.height) {
      for x in self.bounds.x..(self.bounds.x + self.bounds.width) {
        buffer.set_cell(x, y, ' ', self.fg_color, self.bg_color, TextStyle::None)
      }
    }
    
    // Render children
    self.render_children(buffer)
    
    self.needs_render_flag = false
  }
  
  fn handle_event(self: BaseRenderable, event: ComponentEvent) -> Bool {
    if not(self.is_visible()) {
      return false
    }
    
    // Handle event in reverse z-order (top to bottom)
    let sorted_children = self.children.sort_by(fn(a, b) { b.z_index().compare(a.z_index()) })
    
    for child in sorted_children {
      if child.handle_event(event) {
        return true
      }
    }
    
    false
  }
  
  fn is_visible(self: BaseRenderable) -> Bool {
    self.visible
  }
  
  fn set_visible(self: BaseRenderable, visible: Bool) -> Unit {
    self.visible = visible
    self.mark_needs_render()
  }
  
  fn children(self: BaseRenderable) -> Array[BaseRenderable] {
    self.children
  }
  
  fn add_child(self: BaseRenderable, child: BaseRenderable) -> Unit {
    child.set_parent(Some(self))
    self.children.push(child)
    self.mark_needs_layout()
  }
  
  fn remove_child(self: BaseRenderable, child_id: String) -> Unit {
    let index = self.children.search_by(fn(child) { child.id() == child_id })
    match index {
      Some(i) => {
        let child = self.children.remove(i)
        child.set_parent(None)
        self.mark_needs_layout()
      }
      None => ()
    }
  }
  
  fn parent(self: BaseRenderable) -> Option[BaseRenderable] {
    self.parent
  }
  
  fn set_parent(self: BaseRenderable, parent: Option[BaseRenderable]) -> Unit {
    self.parent = parent
    match parent {
      Some(p) => p.mark_needs_layout()
      None => ()
    }
  }
  
  fn z_index(self: BaseRenderable) -> Int {
    self.z_index
  }
  
  fn set_z_index(self: BaseRenderable, z: Int) -> Unit {
    self.z_index = z
    match self.parent {
      Some(parent) => parent.mark_needs_layout()
      None => ()
    }
  }
  
  fn background_color(self: BaseRenderable) -> RGBA {
    self.bg_color
  }
  
  fn set_background_color(self: BaseRenderable, color: RGBA) -> Unit {
    self.bg_color = color
    self.mark_needs_render()
  }
  
  fn foreground_color(self: BaseRenderable) -> RGBA {
    self.fg_color
  }
  
  fn set_foreground_color(self: BaseRenderable, color: RGBA) -> Unit {
    self.fg_color = color
    self.mark_needs_render()
  }
  
  fn needs_layout(self: BaseRenderable) -> Bool {
    self.needs_layout_flag
  }
  
  fn mark_needs_layout(self: BaseRenderable) -> Unit {
    self.needs_layout_flag = true
    match self.parent {
      Some(parent) => parent.mark_needs_layout()
      None => ()
    }
  }
  
  fn needs_render(self: BaseRenderable) -> Bool {
    self.needs_render_flag
  }
  
  fn mark_needs_render(self: BaseRenderable) -> Unit {
    self.needs_render_flag = true
    match self.parent {
      Some(parent) => parent.mark_needs_render()
      None => ()
    }
  }
  
  fn destroy(self: BaseRenderable) -> Unit {
    for child in self.children {
      child.destroy()
    }
    self.children = []
    match self.parent {
      Some(parent) => parent.remove_child(self.id)
      None => ()
    }
  }
}

///|
/// Root container for the entire UI
pub struct RootContainer {
  mut base: BaseRenderable
  mut buffer: TerminalBuffer
}

///|
pub fn RootContainer::new(width: Int, height: Int) -> RootContainer {
  {
    base: BaseRenderable::new("root").with_bounds(0, 0, width, height),
    buffer: TerminalBuffer::new(width, height)
  }
}

///|
pub fn RootContainer::resize(self: RootContainer, width: Int, height: Int) -> Unit {
  self.base.set_bounds(Rect::new(0, 0, width, height))
  self.buffer = TerminalBuffer::new(width, height)
  self.base.mark_needs_layout()
}

///|
pub fn RootContainer::render(self: RootContainer) -> String {
  if self.base.needs_layout() {
    self.base.calculate_layout()
  }
  
  self.base.render(self.buffer)
  self.buffer.to_ansi()
}

///|
pub fn RootContainer::handle_event(self: RootContainer, event: ComponentEvent) -> Bool {
  self.base.handle_event(event)
}

///|
pub impl Renderable for RootContainer {
  fn id(self: RootContainer) -> String {
    self.base.id()
  }
  
  fn bounds(self: RootContainer) -> Rect {
    self.base.bounds()
  }
  
  fn set_bounds(self: RootContainer, bounds: Rect) -> Unit {
    self.base.set_bounds(bounds)
  }
  
  fn layout_constraints(self: RootContainer) -> LayoutConstraints {
    self.base.layout_constraints()
  }
  
  fn set_layout_constraints(self: RootContainer, constraints: LayoutConstraints) -> Unit {
    self.base.set_layout_constraints(constraints)
  }
  
  fn render(self: RootContainer, buffer: TerminalBuffer) -> Unit {
    self.base.render(buffer)
  }
  
  fn handle_event(self: RootContainer, event: ComponentEvent) -> Bool {
    self.base.handle_event(event)
  }
  
  fn is_visible(self: RootContainer) -> Bool {
    self.base.is_visible()
  }
  
  fn set_visible(self: RootContainer, visible: Bool) -> Unit {
    self.base.set_visible(visible)
  }
  
  fn children(self: RootContainer) -> Array[BaseRenderable] {
    self.base.children()
  }
  
  fn add_child(self: RootContainer, child: BaseRenderable) -> Unit {
    self.base.add_child(child)
  }
  
  fn remove_child(self: RootContainer, child_id: String) -> Unit {
    self.base.remove_child(child_id)
  }
  
  fn parent(self: RootContainer) -> Option[BaseRenderable] {
    self.base.parent()
  }
  
  fn set_parent(self: RootContainer, parent: Option[BaseRenderable]) -> Unit {
    self.base.set_parent(parent)
  }
  
  fn z_index(self: RootContainer) -> Int {
    self.base.z_index()
  }
  
  fn set_z_index(self: RootContainer, z: Int) -> Unit {
    self.base.set_z_index(z)
  }
  
  fn background_color(self: RootContainer) -> RGBA {
    self.base.background_color()
  }
  
  fn set_background_color(self: RootContainer, color: RGBA) -> Unit {
    self.base.set_background_color(color)
  }
  
  fn foreground_color(self: RootContainer) -> RGBA {
    self.base.foreground_color()
  }
  
  fn set_foreground_color(self: RootContainer, color: RGBA) -> Unit {
    self.base.set_foreground_color(color)
  }
  
  fn needs_layout(self: RootContainer) -> Bool {
    self.base.needs_layout()
  }
  
  fn mark_needs_layout(self: RootContainer) -> Unit {
    self.base.mark_needs_layout()
  }
  
  fn needs_render(self: RootContainer) -> Bool {
    self.base.needs_render()
  }
  
  fn mark_needs_render(self: RootContainer) -> Unit {
    self.base.mark_needs_render()
  }
  
  fn destroy(self: RootContainer) -> Unit {
    self.base.destroy()
  }
}